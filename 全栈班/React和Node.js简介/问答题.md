## 问答题
### 现代前端与传统前端开发模式上有什么不同？
现代前端：ES6+FP（函数式编程）+Node.js+Webpack（自动转换的打包工具）+React（FB押宝，生态圈好）/Vue/Angular+状态管理+babel（大部分浏览器只支持ES5，这个可以把ES6/7的代码转换成ES5，实现跨浏览器）
一般采用前后分离的架构，前端使用AJAX向后端传送数据，后端使用JSON向前端传送数据
优势：
- 以JS为核心
- 代码模块化
- 开发热更新
- 良好的工程化解决方案
- 组件隔离性好，无门槛复用
- 一般是单页面应用，用户体验性好
- 在数据可视化方面更为专业
传统前端：HTML+CSS+JS+JQuery 
使用JSP或者其他模板引擎填入数据，渲染依赖于后端，是传统MVC结构。
问题：
- HTML/CSS占主导，好的设计师就能玩转
- 没有模块化
- 无法产出符合工程化需求的代码
- 组件隔离性差，无法复用
- 异步控制流混乱
- 多页面应用，多用户体验差

### 命令式编程 与 声明式编程 有何不同？
命令式编程：命令“机器”如何去做事情(how)，这样不管你想要的是什么(what)，它都会按照你的命令实现。
声明式编程：告诉“机器”你想要的是什么(what)，让机器想出如何去做
也即告诉电脑一步步怎么做（自己做，更繁琐）和告诉电脑要做什么的区别（电脑帮忙实现，类似“请了保姆”）


### 什么是 React Compoent? 它一般继承于什么？一般至少实现哪个方法？
React：
“A JavaScript library for building user interfaces”
- react-dom （前端开发）
- react-native (APP 开发)
- react-360 (原名:react-vr VR 开发)
使用情况：BAT、FB、知乎主站和APP
特性：
- Declarative (声明式编程)
- Component-Based（基于组件）
- Learn Once, Write Anywhere(学一次，随处可写程序)

组件（Component）是 React 最强大的功能之一。
- 组件是自定义元素，是 React 的最小重用单元
- 组件应该高内聚，低耦合

### JSX 语法对比普通 JavaScript 有何不同？它是如何解析的？（建议结合网上资料回答）
遇到<会解析成html标签，{则解析成JS。

### 阻塞调用与非阻塞调用有何不同？
（1）单线程模型：
这种模型的问题显而易见，服务端只有一个线程，并发请求（用户）到达只能处理一个，其余的要先等待，这就是阻塞，正在享受服务的请求阻塞后面的请求了。
（2）多线程、线程池模型：
这个模型已经比上一个有所进步，它调节服务端线程的数量来提高对并发请求的接收和响应，但并发量高的时候，请求仍然需要等待，它有个更严重的问题。到代码层面上来讲，我们看看客户端请求与服务端通讯的过程： 服务端与客户端每建立一个连接，都要为这个连接分配一套配套的资源，主要体现为系统内存资源，以 PHP 为例，维护一个连接可能需要 20M 的内存。这就是为什么一般并发量一大，就需要多开服务器。 
（3）异步、事件驱动模型
我们同样是要发起请求，等待服务器端响应；但是与银行例子不同的是，这次我们点完餐后拿到了一个号码，拿到号码，我们往往会在位置上等待，而在我们后面的请求会继续得到处理，同样是拿了一个号码然后到一旁等待，接待员能一直进行处理。 等到饭菜做号了，会喊号码，我们拿到了自己的饭菜，进行后续的处理（吃饭）。这个喊号码的动作在 NodeJS 中叫做回调（Callback），能在事件（烧菜，I/O）处理完成后继续执行后面的逻辑（吃饭），这体现了 NodeJS 的显著特点，异步机制、事件驱动整个过程没有阻塞新用户的连接（点餐），也不需要维护已经点餐的用户与厨师的连接。 基于这样的机制，理论上陆续有用户请求连接，NodeJS 都可以进行响应，因此 NodeJS 能支持比 Java、PHP 程序更高的并发量虽然维护事件队列也需要成本，再由于 NodeJS 是单线程，事件队列越长，得到响应的时间就越长，并发量上去还是会力不从心。 总结一下 NodeJS 是怎么解决并发连接这个问题的：更改连接到服务器的方式，每个连接发射（emit）一个在 NodeJS 引擎进程中运行的事件（Event），放进事件队列当中，而不是为每个连接生成一个新的 OS 线程（并为其分配一些配套内存）。
